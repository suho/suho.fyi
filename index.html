<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>suho.fyi/dev</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        width: 100%;
        background: #000;
      }

      body {
        color: white;
        font-family: "SF Mono", monospace;
        font-weight: 300;
        overflow: hidden;
      }

      #canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }

      .ui {
        position: fixed;
        z-index: 20;
        pointer-events: none;
        font-size: 0.8rem;
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      .header {
        top: 30px;
        left: 30px;
        text-align: left;
      }

      .title {
        display: none;
        font-size: 1.8rem;
        margin-bottom: 8px;
        letter-spacing: 2px;
        background: linear-gradient(135deg, #00d4ff, #0099ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .subtitle {
        opacity: 0.6;
        font-size: 0.7rem;
      }

      .controls {
        bottom: 30px;
        left: 30px;
        opacity: 0.5;
        line-height: 1.6;
      }

      .controls span {
        display: block;
      }

      .stats {
        position: fixed;
        top: 30px;
        right: 30px;
        text-align: right;
        font-size: 0.7rem;
        opacity: 0.5;
      }

      .fps {
        margin-bottom: 10px;
      }

      .profile-link {
        bottom: 30px;
        right: 30px;
        pointer-events: all;
      }

      .profile-link a {
        display: inline-block;
        padding: 10px 20px;
        background: linear-gradient(135deg, #ffffff, #808080);
        color: black;
        text-decoration: none;
        border-radius: 4px;
        font-size: 0.85rem;
        font-weight: 400;
        letter-spacing: 1px;
        text-transform: uppercase;
        transition: opacity 0.3s ease;
        opacity: 0.8;
      }

      .profile-link a:hover {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <div class="ui header">
      <div class="title">COSMOS</div>
      <div class="subtitle">Interactive Visualization</div>
    </div>

    <div class="controls ui">
      <span>Click & Drag to rotate</span>
      <span>Scroll to zoom</span>
      <span>Space to reset</span>
    </div>

    <div class="stats ui">
      <div class="fps">FPS: <span id="fps">60</span></div>
      <div id="info">Loading...</div>
    </div>

    <div class="profile-link ui">
      <a href="https://suho.dev" target="_blank">Visit Profile</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // ==================== SCENE SETUP ====================
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100000,
      );
      const canvas = document.getElementById("canvas");
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true,
      });

      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      const defaultDistance = 1000;
      const minDistance = 100;
      const maxDistance = 3200;
      camera.position
        .set(0, 50, 80)
        .normalize()
        .multiplyScalar(defaultDistance);
      camera.lookAt(0, 0, 0);

      // ==================== CONTROLS ====================
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };
      let cameraRotation = { x: 0, y: 0 };
      const rotationSpeed = 0.005;

      document.addEventListener("mousedown", (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;

          cameraRotation.y += deltaX * rotationSpeed;
          cameraRotation.x += deltaY * rotationSpeed;

          previousMousePosition = { x: e.clientX, y: e.clientY };
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      document.addEventListener("wheel", (e) => {
        e.preventDefault();
        const zoomSpeed = 5;
        const currentDistance = camera.position.length();
        const newDistance =
          currentDistance * (1 + e.deltaY * 0.001 * zoomSpeed);
        const clampedDistance = Math.max(
          minDistance,
          Math.min(maxDistance, newDistance),
        );
        camera.position.normalize().multiplyScalar(clampedDistance);
      });

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          camera.position
            .set(0, 50, 80)
            .normalize()
            .multiplyScalar(defaultDistance);
          cameraRotation = { x: 0, y: 0 };
        }
      });

      // ==================== STARFIELD ====================
      const starsGeometry = new THREE.BufferGeometry();
      const starCount = 5000;
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);

      for (let i = 0; i < starCount * 3; i += 3) {
        const x = (Math.random() - 0.5) * 4000;
        const y = (Math.random() - 0.5) * 4000;
        const z = (Math.random() - 0.5) * 4000;

        starPositions[i] = x;
        starPositions[i + 1] = y;
        starPositions[i + 2] = z;

        const brightness = Math.random();
        starColors[i] = brightness;
        starColors[i + 1] = brightness;
        starColors[i + 2] = brightness * 0.8 + 0.2;
      }

      starsGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(starPositions, 3),
      );
      starsGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(starColors, 3),
      );

      const starsMaterial = new THREE.PointsMaterial({
        size: 0.5,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
      });

      const stars = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(stars);

      // ==================== ANIMATION ====================
      let frameCount = 0;
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        frameCount++;

        const deltaTime = clock.getDelta();

        // Update camera position based on rotation
        const distance = camera.position.length();
        camera.position.x =
          distance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.position.y = distance * Math.sin(cameraRotation.x);
        camera.position.z =
          distance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.lookAt(0, 0, 0);

        // Update stars
        stars.rotation.x += 0.00001;
        stars.rotation.y += 0.00002;

        renderer.render(scene, camera);

        // Update FPS and info
        if (frameCount % 30 === 0) {
          const fps = Math.round(1 / deltaTime);
          document.getElementById("fps").textContent = fps;
          document.getElementById("info").textContent =
            `Stars: ${starCount} | Distance: ${Math.round(camera.position.length())}`;
        }
      }

      animate();

      // ==================== RESIZE HANDLER ====================
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
